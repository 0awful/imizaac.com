{
  "projects": [
    {
      "title": "Jaro-Winkler in swift",
      "subtitle": "An implementation of the Jaro-Winkler algorithm in Swift",
      "description":
        "It's a common algorithm, but when I needed it I couldn't find an example of it in Swift. I transcribed it into swift and then published my work on github and roseta code.",
      "projecturl": "URLWhereItIsHosted",
      "codeurl": "https://github.com/imizaac/SwiftJaroWinkler",
      "id": "SwiftJaroWinkler",
      "writeup":
        "I'm not going to say I came up with this or that I came to this conclusion without help from other people. Instead I had a problem. I knew I needed a way to compute string distance in swift, but I couldn't find a library that met my needs. I wanted a very lightweight implementation that extends strings to have an integrated Jaro Winkler function. Using the roseta code definitions of the Jaro Winkler algorithm I transcribed this into swift. I reference Python, Javascript, Objective-C, and Ruby as I was working on this. I can't say it was easy for me at the time, but it was the moment when it clicked that all programming languages are really the same, just with different ornamentations. I don't know if anyone has ever used it, but in my case it was exactly what I needed. It provides a function that gives you a way to Jaro Winkler compare two strings and it gives you the ability to call .jaroWinkler on a string and compare it to another. It is written with serveral early exit conditions to cause a modest increase in performance. Finally I also wrote an extension for arrays so you can call .jaroWinklerSort on an array and then sort by the values of the string distance function. It was a fun project that didn't take too long and I'm happy with how it came out."
    },
    {
      "title": "Shared Canvas",
      "subtitle":
        "A online paint style app, where everyone has the same canvas to paint on",
      "description":
        "Using HTML5 canvas, websockets, and jquery this app mimics MSPaint with the twist that all the users are using the same canvas",
      "projecturl": "https://sharedcanv.us",
      "codeurl": "https://github.com/imizaac/SharedCanvas",
      "id": "sharedcanvas",
      "writeup":
        "The inpiration of the project was the reddit april fools project of 2017 which was /r/place. This was a 1000 x 1000 grid which any reddit user could change the color of a pixel once every 60 seconds. I was applying this to a smaller user base and so I gave the users more power. Rather than a single pixel I gave them a brush stroke that decreased in radius as they moved it. I gave them a shorter timer. Finally I left in a bug that I told the users about when I released it. From a technical standpoint it isn't super complex. A user has a canvas that they modify with jquery scripts. When they make a change to the canvas they send an update to the server that the server then passes on to the other clients. This happens via websockets with the library socket.io on a node server I built up for this project. The timer exists to prevent griefing. This timer is client side which presents a problem. Any user has the ability to refresh the page or use multiple tabs to avoid the timer. I discovered this when I put it into beta, and when I released it I brought this up to empower the few users that were interested in using it. I could fix this by adding IP logging, authentication, or making the user enter the page on cooldown. I do not want to do authentication or starting the user on cooldown because this would result in a poor first time user experience. IP logging will be implemented in an upcomming rewrite of the site. The data is a key value pairing of a string and an array. The string is a randomly generated alphabetical key that has both uppercase and lowercase letters with a total length of 4 digits. This leads to a namespace of 52^4 and a chance of a collision being roughly 1 in 52^4. This project originated as a collobrative art project for a humanities class of 30 people. Given a user base of at most 30 people collision is effectively impossible. If I was to roll this out for production I would use a hash function to generate sequential values on the server. The server would then give these values to the clients as they gained the right to draw another line. I could also take the exact same key generation method, move it to the server, and then validate that it has not been used before. Either of these would prevent collisions entirely. If the client gave the server a value that was not the one I gave them I would reject their modification as I would know they are a bad actor. This would also be a mechanism by which timer abuse could be prevented. Colisions are worth avoiding because a collision would cause the original line to be deleted and replaced with the new line. There is an interesting possible rewrite of this project where there is a limited namespace and an intentional collision system. This would cause old lines to disapear and replace themselves with new lines. It would also prevent performance degredation. Plannned updates include: room functionality, mobile support, server side timing and key generation as well as IP logging, and opt in athentication. This will allow for someone to create a room that they then have invite and admin priveges over. Then people could doodle with their friends and customize the settings of a room. Athentication will be built out simply to support this function. Periodic wipes of rooms will happen along with periodic resets of the main canvas. This will be based upon time since last doodle and a max duration of a room. Finally the canvas will be translated into an image format and provided to the users on first load rather than a heap of data being sent inefficiently over websockets as it is now. Websockets perform best with small chunks of data being sent rather than kilobytes of data being sent regularly. Currently this is a theoretical problem as on first load a person is given all key values needed to generate the canvas. This causes decreasing performance as usage increases. If you are interested in seeing the project click the project button. I recommend opening the app in two brower windows and watching how quickly you get the updates in the second window."
    },
    {
      "title": "Algorithms in swift",
      "subtitle": "A collection of algorithms in swift",
      "description":
        "After I was given the recomendation to work on my algorithm skills I started work on serveral algorithms at leetcode.com",
      "projecturl": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "BulkAlgorithms",
      "writeup":
        "What you'll find here is several algorithms taken from leetcode.com and solved in swift. Given my background in working on apps and websites this was a nice change of pace. From here I developed the basics that helped me solve many other problems I encounted when working with data and APIs. What was most interesting for me was working on linked list problems. I had never encountered the linked list data type before this. Immediately I rejected this as a totally useless data type as I struggled on the problem. Later on I learned that a blockchain is really an encrypted linked list making me realize that I was stupid to jump to a conclusion like that. Another interesting part of this project was how Leetcode ranks you. At the end of your solution it shows you your algorithm's performance versus the performance of other people's algorithms. It showed me how many of my first solutions weren't the best and how solving the problems again from a different angle can give better results. After a couple weeks working on these problems I found myself sometimes getting the best solution first. Usually the best scores are based upon having smart exit conditions and not complicating the problem. Overall it really gave me an appreciation for those who broke ground in the study of algorithms. In most of my day to day programming I can just call .sort() or .filter() to get where I need to go, but those who first arrived at the idea of a bubble sort, merge sort, or binary search really paved the way for modern developers. This experience has left me in a position where I am comfortable taking on a weird algorithm problem."
    },
    {
      "title": "ImIzaac.com",
      "subtitle": "This site and my experience with it",
      "description":
        "This site was an early project I had with React. It was through this project that I developed the comfort to start putting out my react work.",
      "projecturl": "https://www.imizaac.com",
      "codeurl": "https://github.com/imizaac/imizaac.com",
      "id": "imizaac",
      "writeup":
        "The idea was simple; a living resume and portfolio. The implementation was built around a couple ideas. First I wanted to use React. That's because I just completed Brian Holt's class on React and I needed something to build with react. Next I wanted my page to be worth showing off. I could do it with squarespace, with html, css, js, wordpress, and all manner of things, but a SPA feels different. I wanted to present that feeling. Finally I wanted it to look good, and that is something I know I can do with react. Using the library Material-UI published by google I was able to get some shortcuts in some areas. Using CSS I was able to solve rendering problems. The project cards have a challenge of rending the right number of them in the right positions. If you just float them they don't reduce the number rendering properly and they also are not centered. Both of these things aren't acceptable UI. I solved this with css grids and a @media query to set the right number of them based upon screen size. There was a rendering problem that would occur when a user opened the writeup window. When you opened it all the other items on the screen would move. This was very ugly and bothered me a lot. I solved this with some CSS magic."
    },
    {
      "title": "Binance Auto Trader",
      "subtitle": "An algorithm that automatically trades cryptocurrencies",
      "description":
        "An automated index fund build upon the binance cryptocurrency exchange. It allows for a user to automatically balance all of their funds to have the same monitary value",
      "projecturl": "https://github.com/imizaac/BinanceAutoTrader",
      "codeurl": "https://github.com/imizaac/BinanceAutoTrader",
      "id": "BinanceAutoTrade",
      "writeup":
        "The fundamental investment strategy is to create an index fund. In the cryptocurrency space this does not exist. So I made it. It is actually really simple, but it has some interesting challenges. First you need to get the balances of your account, the price values of the currencies, and the requirements of the market. Then you need to calculate what you need to sell and what you need to buy. Then you need to execute your orders. It makes most sense to execute your sell orders first and then your buy orders finally resulting in a balanced portfolio. This project was never intended to be made public and has not been changed since I added it to the site so what you are seeing here is my code as I wrote it for my eyes only. The interesting challenge of the project is assigning a real value to the coins. First everything is on multiple exchanges, they are on the BTC exchange, the ETH exchange, and some are on the LTC, USDT and BNB exchanges. This means that they have between 2 and 4 prices. Which has an opperturnity for arbitrage. If you are interested in this I invite you to look at my Binance Arbitrage algorithm which works on this area. The second problem with pricing is stocks and cryptos don't have one price. They have a buy and a sell price. If you are looking for an instant atomic pairing of events you are going to end up with conflicting values you can only evaluate your personal worth in terms of your sell price, as this is what you will capitalize on, next you will buy at the buy price and the end result is a loss. Why would you want to do this then? The assumption is that all prices are pseudo random numbers but on average the value is either constant or increasing. This means that you are buying items at a relative low and selling at a relative high. Despite the loss I theorized that this would generate a profit. I was right, but that may have been the territory as I entered the market just before a crazy bull run and I exited just before the market turned bearish. This project taught me a lot about handling API calls. First thing first with APIs are that you have to follow their rules. You make a request when they let you make a request. No more often. Next you make a request how they require you to make a request. In my circumstance that meant that I had to strictly present numbers within a certain range. This was not universal to all coins and therefore I had to handle large configuration files that could theoretically change at any time and had to be pulled every time I ran the algorithm. It forced me to build my algorithm in a functional style and make no assumption about the rules of the api. Finally I had to work heavily with promises. This was a pain at first but now I really like them. Who would have thought that using a million promises would make you okay with them."
    },
    {
      "title": "Binance Arbitrage",
      "subtitle": "Executing Real Time Arbitrage",
      "description":
        "Using websockets and monitoring numerous routes I try to make money from nothing",
      "projecturl": "https://github.com/imizaac/BinanceArbitrage/",
      "codeurl": "https://github.com/imizaac/BinanceArbitrage/",
      "id": "BinanceArbitrage",
      "writeup":
        "Money for nothing. That was the goal. Arbitrage is profiting off of a price imbalance. If something somewhere is too cheap you buy it and sell it at a profit. My opportunity is Binance. Binance prices cryptocurrency in multiple markets. BTC, ETH, BNB, LTC, and USDT. In theory you could move money through the markets because of this. Starting on one exchange you make a buy order, then make two sell orders to end up where you started with a larger sum of money. Before I set out on this I needed to know that it would be profitable. I set up my computer monitoring the markets and theortically acting on routes. I found that over a 24 hour period there were tens of thousands of dollars in possible transactions that you could take to make money. It was amazing I was only monitoring one possible trade. This was the easiest money I had ever seen. I only wondered why nobody had done this before. My system was simple. Subscribe to websocket data from multiple coins and create all possible routes between them. Whenever a coin changes in price, if it would make a route more profitable, recalculate that route. This prevented unnessecary computation which in theory would allow for the tranactions to be acted on quicker. Next you have money sitting in all the coins on a route. That way you can take all the profitable trades simultaneously. This means that you can beat anyone who is keeping all their money in one coin. Looking at the numbers I couldn't believe it, so I checked my code. Turns out I was caculating profitability wrong. Fixing the bug I looked at profitability again. I found that you could make roughly a dollar a day off of nearly 100k moving through a single path of trades. Not the best return on investment. But what does this mean? It means that someone out there is already running an algorithm just like this and getting these trades in order to keep price balance. This normalizes prices across these markets. A final note about this. I found that you could make $1 a day off of a single route. I might be wrong on my calculations of required funds, as this is not the best code I've written, but what I do know is that there were at time of my research 93 coins on BTC and ETH, this means you have 93x2 routes on just this these two exchanges, which is a total of 186 possible routes to find trades on. That being said, the number of coins on these markets has likely increased, and this does not include the other markets which has a mulpicitive impact on the profitability of this method. Despite me abandoning this method it is very likely that you can find a reasonable ROI through this methodology. What did learn? I learned about websocket code, specifically how to structure a calculation so that you only do it when you need to in order to best optimize for performance. Within the context of websockets performance is a valuable thing. In other areas you can have bad performance, but here you really can't, as the real time nature of it is lost if write blocking code."
    }
  ]
}
