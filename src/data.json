{
  "projects": [
    {
      "title": "Jaro-Winkler in swift",
      "subtitle": "An implementation of the Jaro-Winkler algorithm in Swift",
      "description":
        "It's a common algorithm, but when I needed it I couldn't find an example of it in Swift. I transcribed it into swift and then published my work on github and roseta code.",
      "url": "URLWhereItIsHosted",
      "codeurl": "https://github.com/imizaac/SwiftJaroWinkler",
      "id": "SwiftJaroWinkler",
      "writeup":
        "I'm not going to say I came up with this or that I came to this conclusion without help from other people. Instead I had a problem. I knew I needed a way to compute string distance in swift, but I couldn't find a library that met my needs. I wanted a very lightweight implementation that extends strings to have an integrated Jaro Winkler function. Using the roseta code definitions of the Jaro Winkler algorithm I transcribed this into swift. I reference Python, Javascript, Objective-C, and Ruby as I was working on this. I can't say it was easy for me at the time, but it was the moment when it clicked that all programming languages are really the same, just with different ornamentations. I don't know if anyone has ever used it, but in my case it was exactly what I needed. It provides a function that gives you a way to Jaro Winkler compare two strings and it gives you the ability to call .jaroWinkler on a string and compare it to another. It is written with serveral early exit conditions to cause a modest increase in performance. Finally I also wrote an extension for arrays so you can call .jaroWinklerSort on an array and then sort by the values of the string distance function. It was a fun project that didn't take too long and I'm happy with how it came out."
    },
    {
      "title": "Shared Canvas",
      "subtitle":
        "A online paint style app, where everyone has the same canvas to paint on",
      "description":
        "Using HTML5 canvas, websockets, and jquery this app mimics MSPaint with the twist that all the users are using the same canvas",
      "url": "https://Sharedcanv.us",
      "codeurl": "https://github.com/imizaac/SharedCanvas",
      "id": "sharedcanvas",
      "writeup":
        "The inpiration of the project was the reddit april fools project of 2017 which was /r/place. This was a 1000 x 1000 grid which any reddit user could change the color of a pixel once every 60 seconds. I was applying this to a smaller user base and so I gave the users more power. Rather than a single pixel I gave them a brush stroke that decreased in radius as they moved it. I gave them a shorter timer. Finally I left in a bug that I told the users about when I released it. From a technical standpoint it isn't super complex. A user has a canvas that they modify with jquery scripts. When they make a change to the canvas they send an update to the server that the server then passes on to the other clients. This happens via websockets with the library socket.io on a node server I built up for this project. The timer exists to prevent griefing. This timer is client side which presents a problem. Any user has the ability to refresh the page or use multiple tabs to avoid the timer. I discovered this when I put it into beta, and when I released it I brought this up to empower the few users that were interested in using it. I could fix this by adding IP logging, authentication, or making the user enter the page on cooldown. I do not want to do authentication or starting the user on cooldown because this would result in a poor first time user experience. IP logging will be implemented in an upcomming rewrite of the site. The data is a key value pairing of a string and an array. The string is a randomly generated alphabetical key that has both uppercase and lowercase letters with a total length of 4 digits. This leads to a namespace of 52^4 and a chance of a collision being roughly 1 in 52^4. This project originated as a collobrative art project for a humanities class of 30 people. Given a user base of at most 30 people collision is effectively impossible. If I was to roll this out for production I would use a hash function to generate sequential values on the server. The server would then give these values to the clients as they gained the right to draw another line. I could also take the exact same key generation method, move it to the server, and then validate that it has not been used before. Either of these would prevent collisions entirely. If the client gave the server a value that was not the one I gave them I would reject their modification as I would know they are a bad actor. This would also be a mechanism by which timer abuse could be prevented. Colisions are worth avoiding because a collision would cause the original line to be deleted and replaced with the new line. There is an interesting possible rewrite of this project where there is a limited namespace and an intentional collision system. This would cause old lines to disapear and replace themselves with new lines. It would also prevent performance degredation. Plannned updates include: room functionality, mobile support, server side timing and key generation as well as IP logging, and opt in athentication. This will allow for someone to create a room that they then have invite and admin priveges over. Then people could doodle with their friends and customize the settings of a room. Athentication will be built out simply to support this function. Periodic wipes of rooms will happen along with periodic resets of the main canvas. This will be based upon time since last doodle and a max duration of a room. Finally the canvas will be translated into an image format and provided to the users on first load rather than a heap of data being sent inefficiently over websockets as it is now. Websockets perform best with small chunks of data being sent rather than kilobytes of data being sent regularly. Currently this is a theoretical problem as on first load a person is given all key values needed to generate the canvas. This causes decreasing performance as usage increases. If you are interested in seeing the project click the project button. I recommend opening the app in two brower windows and watching how quickly you get the updates in the second window."
    },
    {
      "title": "Algorithms in swift",
      "subtitle": "A collection of algorithms in swift",
      "description":
        "After I was given the recomendation to work on my algorithm skills I started work on serveral algorithms at leetcode.com",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "BulkAlgorithms",
      "writeup":
        "What you'll find here is several algorithms taken from leetcode.com and solved in swift. Given my background in working on apps and websites this was a nice change of pace. From here I developed the basics that helped me solve many other problems I encounted when working with data and APIs. What was most interesting for me was working on linked list problems. I had never encountered the linked list data type before this. Immediately I rejected this as a totally useless data type as I struggled on the problem. Later on I learned that a blockchain is really an encrypted linked list making me realize that I was stupid to jump to a conclusion like that. Another interesting part of this project was how Leetcode ranks you. At the end of your solution it shows you your algorithm's performance versus the performance of other people's algorithms. It showed me how many of my first solutions weren't the best and how solving the problems again from a different angle can give better results. After a couple weeks working on these problems I found myself sometimes getting the best solution first. Usually the best scores are based upon having smart exit conditions and not complicating the problem. Overall it really gave me an appreciation for those who broke ground in the study of algorithms. In most of my day to day programming I can just call .sort() or .filter() to get where I need to go, but those who first arrived at the idea of a bubble sort, merge sort, or binary search really paved the way for modern developers. This experience has left me in a position where I am comfortable taking on a weird algorithm problem."
    },
    {
      "title": "ImIzaac.com",
      "subtitle": "This site and my experience with it",
      "description":
        "This site was an early project I had with React. It was through this project that I developed the comfort to start putting out my react work.",
      "url": "https://www.imizaac.com",
      "codeurl": "https://github.com/imizaac/imizaac.com",
      "id": "imizaac",
      "writeup":
        "The idea was simple; a living resume and portfolio. The implementation was built around a couple ideas. First I wanted to use React. That's because I just completed Brian Holt's class on React and I needed something to build with react. Next I wanted my page to be worth showing off. I could do it with squarespace, with html, css, js, wordpress, and all manner of things, but a SPA feels different. I wanted to present that feeling. Finally I wanted it to look good, and that is something I know I can do with react. Using the library Material-UI published by google I was able to get some shortcuts in some areas. Using CSS I was able to solve rendering problems. The project cards have a challenge of rending the right number of them in the right positions. If you just float them they don't reduce the number rendering properly and they also are not centered. Both of these things aren't acceptable UI. I solved this with css grids and a @media query to set the right number of them based upon screen size. There was a rendering problem that would occur when a user opened the writeup window. When you opened it all the other items on the screen would move. This was very ugly and bothered me a lot. I solved this with some CSS magic."
    },
    {
      "title": "someTitle",
      "subtitle": "this is the subtitle",
      "description": "description",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "idnumber4",
      "writeup": "longWriteup"
    },
    {
      "title": "someTitle",
      "subtitle": "this is the subtitle",
      "description": "description",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "idnumber5",
      "writeup": "longWriteup"
    },
    {
      "title": "someTitle",
      "subtitle": "this is the subtitle",
      "description": "description",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "idnumber6",
      "writeup": "longWriteup"
    },
    {
      "title": "someTitle",
      "subtitle": "this is the subtitle",
      "description": "description",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "idnumber7",
      "writeup": "longWriteup"
    },
    {
      "title": "someTitle",
      "subtitle": "this is the subtitle",
      "description": "description",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "idnumber8",
      "writeup": "longWriteup"
    },
    {
      "title": "someTitle",
      "subtitle": "this is the subtitle",
      "description": "description",
      "url": "URLWhereItIsHosted",
      "codeurl": "githubURL",
      "id": "idnumber9",
      "writeup": "longWriteup"
    }
  ]
}
